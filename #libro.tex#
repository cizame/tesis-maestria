% Created 2015-11-09 lun 12:33
% Indented LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{listings}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage[margin=2.5cm]{geometry}
\usepackage[mono=false]{libertine}
\usepackage[libertine,timesmathacc]{newtxmath}
\usepackage[scaled=0.7]{luximono}
\usepackage{xcolor}
\usepackage[spanish, mexico]{babel}
\date{}
\title{Introducción}
\hypersetup{
 pdfauthor={},
 pdftitle={Introducción},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 24.3.1 (Org mode N/A)}, 
 pdflang={Spanish}}
\begin{document}

\maketitle
\tableofcontents


\section{Preliminares}
\label{sec:orgheadline3}
Cuando al principio de una conversación escuchamos la frase "El
estudio de los algoritmos", muchos de nosotros podríamos suponer que
el tema centrar de la charla estará relacionado a una computadora;
sin embargo, pese a lo que podríamos suponer, para plantear y
estudiar algoritmos no requerimos de ningun aparato, de hecho su
existencia es anterio a estos.

\subsection{Algoritmos}
\label{sec:orgheadline2}

La palabra algoritmo tiene su origen en el libro "\textbf{Algoritmi de
numero Indorum}" de la traducción al latín del libro "Hisab al-yabr
wa'l muqabala" del matemático, astrónomo y geógrafo persa-musulman
\textbf{Abu Abdallah Muhammad ibn Musa al-Jwarizmi} mejor conocido como
al-Khwarizmi.

En dicho libro, el matemático enlista una serie de
pasos a seguir para resolver una ecuación de segundo grado, que por
supuesto siempre genera la solución correcta. Esta serie de
pasos se puede considerar como uno de los primeros algoritmos de la
historia. 

Un \textbf{algoritmo} es una serie de pasos finitos, predeterminados y bien
definidos a seguir de forma ordenada que permitan, mediante una
serie de datos de inicio, obtener uno o mas datos de salida los
cuales se interpretan como solución a un problema determinado.


\#*** Partes de un algoritmo

\begin{description}
\item[{Entrada:}] Son los datos, proporcionados por el problema planteado,
\end{description}
que requiere el siguiente paso para su funcionamiento.

\begin{description}
\item[{Proceso:}] Este es el momento en el que se toman los datos de
\end{description}
entrada y se manipulan de acuerdo a los pasos preestablesidos para
procesarlos.

\begin{description}
\item[{Salida:}] Resultado final arrojado por el proceso.
\end{description}

\paragraph{Ejemplo: algoritmo para lavarse las manos.}
\label{sec:orgheadline1}

\begin{itemize}
\item Entrada: Agua, Jabon y Manos.
\item Proceso:
\begin{itemize}
\item Moja ambas manos
\item Pon jabon en una mano
\item Frota ambas manos
\item Enjuaga las manos hasta que no tengan jabon
\end{itemize}
\item Salida: Manos limpias y sin jabon
\end{itemize}

Algo que podría parecer obvio pero que aún no se ha mencionado es
que sin importar el número de veces que se repita un algoritmo, si
se tienen los mismos valores en las entradas, entonces éste siempre debe de
arrojar el mismo resultado.


\section{}
\label{sec:orgheadline10}

Como se menciona en \cite{MR2572804} "Introduction to Algorithms" tercera edición.

\ldots{}Antes de que hubiera computadoras, había algoritmos. Pero ahora
que hay computadoras, incluso hay más algoritmos y estos se
encuentran en el corazón de la informatica\ldots{}

\subsection{La notación O}
\label{sec:orgheadline9}

\subsubsection{Definición}
\label{sec:orgheadline6}

\paragraph{Notación O}
\label{sec:orgheadline4}

Decimos que \(f(n)=O(g(n))\) si existen \(M,n_{0}\) tales que
\(|f(n)|\leq Mg(n)\) para \(n\geq n_{0}\).

\paragraph{Ejemplo}
\label{sec:orgheadline5}

Sea \(P(n)=a_{0}+a_{1}n+\cdots+a_{m}n^{m}\) un polinomio de grado
cuando mucho \(m\). Entonces \(P(n)=O(n^{m})\). Pues:
\begin{align*}
|P(n)| & \leq |a_0|+|a_1|n+\cdots+|a_m|n^m \\
       & = \left(\frac{|a_0|}{n^m}+\frac{|a_1|}{n^{m-1}}+\cdots+\frac{|a_{m-1}|}{n}+|a_m|\right)n^m\\
       & \leq (|a_0|+|a_1|+\cdots+|a_m|)n^m,
\end{align*}
y entonces si \(n_{0}=1\) y \(M=|a_0|+|a_1|+\cdots+|a_m|\), se
tiene que \(|P(n)|\leq Mn^{m}\) para \(n\geq n_{0}\).

\subsubsection{Propiedades}
\label{sec:orgheadline8}

\paragraph{}
\label{sec:orgheadline7}
Tenemos que:

\begin{itemize}
\item Si \(f(n)=O(g(n))\) y \(h(n)=O(g(n))\), entonces \(f(n)+h(n)\in O(g(n))\).
\item Si \(f(n)=O(g(n))\) y \(h(n)\geq 0\), entonces \(f(n)h(n)=O(h(n)g(n))\).
\end{itemize}


\section{Algoritmos}
\label{sec:orgheadline20}

\subsection{Algoritmos de ordenamiento}
\label{sec:orgheadline14}

\subsubsection{Cita de Knuth}
\label{sec:orgheadline11}

\begin{quote}
Computer manufacturers estimate that over 25 percent of the running
time on their computers is currently being spent on sorting, when all
their customers are taken into account. There are many installations
in which sorting uses over half of the computing time. From these
statistics we may conclude either that \textbf{(i)} there are many important
applications of sorting, or \textbf{(ii)} many people sort when they shouldn't,
or \textbf{(iii)} inneficient sorting algorithms are in common use. The real
truth probably involves some of the three alternatives.
\end{quote}

\subsubsection{Características de un buen algoritmo}
\label{sec:orgheadline12}

\begin{itemize}
\item Debe estar descrito en términos claros, de modo que pueda convertirse
en un programa para una computadora.
\item Debe tener una condición inicial.
\item Debe finalizar después de una cantidad finita de pasos.
\item Debe finalizar con la respuesta correcta.
\item ¿Es rápido?
\end{itemize}

\subsubsection{{\bfseries\sffamily TODO} Ordenamiento de una lista}
\label{sec:orgheadline13}

\begin{itemize}
\item Primero encontramos el máximo de una lista de \(n\) elementos en
\(n-1\) pasos y demostramos que es óptimo.
\item Por lo tanto una lista de \(n\) elementos se puede ordenar en
\(n(n-1)\) pasos.
\item Luego vimos el método de ordenamiento como un torneo de
eliminación directa y vimos que se puede ordenar en \(n\log n\)
pasos.
\end{itemize}
\subsection{Algoritmos de camino más corto}
\label{sec:orgheadline19}
\subsubsection{Búsqueda en anchura}
\label{sec:orgheadline15}
\lstset{basicstyle=\scriptsize\ttfamily,commentstyle=\itshape\ttfamily\color{green!50!black},keywordstyle=\bfseries\color{blue},stringstyle=\color{purple},breaklines=true,showstringspaces=false,language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def bfs(G, s):
    P, Q = {s: 0}, deque([s]) # Parents and FIFO queue
    while Q:
        u = Q.popleft() # Constant-time for deque
        for v in G.neighbor_out_iterator(u):
            if v in P: continue # Already has parent
            P[v] = P[u]+1 # Reached from u: u is parent
            Q.append(v)
    return P
\end{lstlisting}

\subsubsection{Algoritmo de Dijkstra}
\label{sec:orgheadline16}
\lstset{basicstyle=\scriptsize\ttfamily,commentstyle=\itshape\ttfamily\color{green!50!black},keywordstyle=\bfseries\color{blue},stringstyle=\color{purple},breaklines=true,showstringspaces=false,language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def dijkstra(G,s):
    L,T,P = {s:0},[(0,s)],set([])
    while T:
        _, v = heappop(T)
        P.add(v)
        for u in G[v]:
            if u in L:
                if L[u] > L[v]+G[v][u]:
                    L[u] = L[v]+G[v][u]
            else:
                if u not in P:
                    L[u]=L[v]+G[v][u]
                    heappush(T,(L[u],u))
    return L
\end{lstlisting}

\subsubsection{Algoritmo de Ford}
\label{sec:orgheadline17}
Este algoritmo algo tenía mal

\lstset{basicstyle=\scriptsize\ttfamily,commentstyle=\itshape\ttfamily\color{green!50!black},keywordstyle=\bfseries\color{blue},stringstyle=\color{purple},breaklines=true,showstringspaces=false,language=Python,label= ,caption= ,captionpos=b,numbers=none}
\begin{lstlisting}
def ford(G,s,L=None):
    V=G.keys()
    if L==None:
        L={}
        for i in V:
            L[i]=inf
        L[s]=0
    there_is=False
    i=0
    print L
    while not(there_is) and i<len(V):
        u=V[i]
        j=0
        A=G[u].keys()
        while not(there_is) and j<len(A):
            v = A[j]
            there_is = L[u] < inf and L[v] > L[u]+G[u][v]
            j = j+1
        i = i+1
    if there_is:
        L[v]=L[u]+G[u][v]
        print u,v
        ford(G,s,L)
    else:
        print "Ya"
        print L
        return L
\end{lstlisting}
\subsubsection{Algoritmo de Floyd}
\label{sec:orgheadline18}

\bibliographystyle{plain}
\bibliography{./referencia}
\end{document}